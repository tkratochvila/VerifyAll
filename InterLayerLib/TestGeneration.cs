using System;
using System.Collections.Generic;
using System.IO;
using System.IO.Compression;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading.Tasks;

namespace InterLayerLib
{
    class TestGeneration
    {
        const string hiliteTemplate = @"<?xml version=""1.0""?>
       <Language name=""HonEARS"">
          <Requirements>fileName.EARS</Requirements>
       </Language>
";

        const string DTDcontent = @"<!-- This DTD contains Entity declarations referenced by.hilite files -->";

        const string VarDataTypes = @"";

        const string EnumVariables = "#symbol,enumname\n\r\n\r"; // #symbol,enumname,modality

        const string EnumDefinitions = "#enumname,enumerationliteral,enumvalue\n\r\n\r";

        public static string GenerateHiLiTEZipFromEARS(string EARSFileName, string EARSContent, string variables, string datatypes, string TSTEARSContent)
        {
            string HiLiTEFileName = Path.ChangeExtension(EARSFileName, "zip");
            EARSFileName = Path.GetFileName(EARSFileName);
            using (var memoryStream = new MemoryStream())
            {
                using (var archive = new ZipArchive(memoryStream, ZipArchiveMode.Create, true))
                {
                    AddFileWithContent(Path.ChangeExtension(EARSFileName, ".hilite"), hiliteTemplate.Replace("fileName.EARS", EARSFileName), archive);
                    AddFileWithContent(EARSFileName, EARSContent, archive);
                    AddFileWithContent("HiLiTEEntities.dtd", DTDcontent, archive);
                    foreach (Match m in Regex.Matches(variables, @"([A-Za-z0-9]+)dot"))
                    {
                        if (TSTEARSContent.Contains($"{ m.Groups[1] }."))
                        {
                            variables = variables.Replace(m.Value, m.Groups[1].ToString());
                            datatypes = datatypes.Replace(m.Value, m.Groups[1].ToString());
                        }
                    }
                    var vars = variables.Split(new char[] { '\n', '\r' }, StringSplitOptions.RemoveEmptyEntries).ToList();
                    var new_vars = new List<string>();
                    // Remove dots that cannot be in .csv files, since T2T does not process them correctly.
                    string TSTEARSWithoutDots = Regex.Replace(TSTEARSContent, @"previous_([a-zA-Z]*)\.([a-zA-Z]*)\.?([a-zA-Z]*)\.?([a-zA-Z]*)", "previous_$1$2$3$4");
                    // For all variables with previous_ prefix, add them to the .csv files.
                    vars.Where(v => TSTEARSWithoutDots.Contains($"previous_{ Regex.Match(v, @"^([A-Za-z0-9]+) ").Groups[1] }")).
                        ToList().ForEach(nv => new_vars.Add($"previous_{ nv }"));
                    vars.AddRange(new_vars);
                    variables = $"{ variables }{ string.Join("\n", new_vars)}";
                    variables = Regex.Replace(string.Join("\n\r", vars.Where(v => !v.EndsWith("Enumeration)"))), @" (Bool|Float|Int|Unknown)\)", ", ${1}32,,").Replace(" Bool32,,", " Bool,,").Replace("Unknown32", " Int32");
                    AddFileWithContent("VarDataTypes.csv", $"{ VarDataTypes }{ variables }", archive);
                    variables = string.Join("\n", vars.Where(v => v.EndsWith("Enumeration)"))).Replace(" ", ",").Replace("Enumeration)", "Enumeration");
                    AddFileWithContent("EnumVariables.csv", $"{ EnumVariables }{ variables}  ", archive);
                    datatypes = datatypes.Replace(")))", "");
                    variables = "";
                    int i = 0;
                    datatypes.Split(new char[] { '\n', '\r' }).ToList().ForEach(line => line.Split(new char[] { ' ' }).Skip(1).ToList().ForEach(value => variables += $"{ line.Remove(line.IndexOf(' ')) },{ value },{i++}\n") );
                    // For example, from each line: "airportsizeEnumeration medium small"
                    // generate as many lines as values like this:
                    // airportsizeEnumeration,medium,0
                    // airportsizeEnumeration,small,1
                    AddFileWithContent("EnumDefinitions.csv", EnumDefinitions + variables, archive);
                    // Probably java on the OSLC windows verification server Unite cannot handle directories inside the archive generated by C# irrespective of compression level
                }

                using (var fileStream = new FileStream(HiLiTEFileName, FileMode.Create))
                {
                    memoryStream.Seek(0, SeekOrigin.Begin);
                    memoryStream.CopyTo(fileStream);
                }
            }
            
            return HiLiTEFileName;
        }

		/// <summary>
		/// The Zip archive is supposed to contain the .hilite file and any file referenced from it
		/// This function also stores the zip file for further processing.
		/// </summary>
		/// <param name="fileName">existing file with .zip extension</param>
		public static List<string> importZipArchive(string fileName)
		{
			List<string> entries = new List<string>();

			using (ZipArchive archive = ZipFile.OpenRead(fileName))
			{
				ZipArchiveEntry HiLiTEFile = archive.Entries.FirstOrDefault(e => e.FullName.EndsWith(".hilite", StringComparison.OrdinalIgnoreCase));
				if (HiLiTEFile != null)
				{
					using (var reader = new StreamReader(HiLiTEFile.Open(), true))
					{
						string line;
                        var lineWithoutSingleLineComments = new StringBuilder();

                        while ((line = reader.ReadLine()) != null)
                        {
                            lineWithoutSingleLineComments.Append(Regex.Replace(line, @"<!--(.*?)-->",""));
                        }
                        // TODO add support for multiple files separated by comma:
                        //< !--file(s) containing normal(continuous) processing requirements; multiple filenames are ',' separated-- >

                        // Remove also multi-line xml comments
                        line = Regex.Replace(lineWithoutSingleLineComments.ToString(), @"<!--(.*?)-->", "");

                        // if enumeration define is referenced it have to be is present in the archive
                        VerifyReferencedFile(@"<EnumerationDefine>\s*([^<]*)<", fileName, archive, HiLiTEFile, line);
						// if Variable Files are referenced it have to be is present in the archive
						VerifyReferencedFile(@"<VariableFiles>\s*([^<]*)<", fileName, archive, HiLiTEFile, line);
						// if Requirement Files are referenced it have to be is present in the archive
						if (! VerifyReferencedFile(@"<RequirementFiles>\s*([^<]*)<", fileName, archive, HiLiTEFile, line))
                        {
							// if there is no requirement file present, check also model. (Interpretation of .hilite file by Anitha from 4th 10. 2021)
							// if a model is referenced it have to be is present in the archive
							VerifyReferencedFile(@"<Model\s*name=""([^""]*)""", fileName, archive, HiLiTEFile, line);
						}
                    }
				}
				// store the full names of all files (skip directories)
				entries = archive.Entries.Where(e => e.Name.Length > 0).Select(e => e.FullName).ToList();
			}

			return entries;
		}

        private static bool VerifyReferencedFile(string regEx, string fileName, ZipArchive archive, ZipArchiveEntry HiLiTEFile, string line)
        {
			Match m = Regex.Match(line, regEx, RegexOptions.IgnoreCase);
			if (m.Success)
            {
                string referencedFiles = $"{ Path.Combine(Path.GetDirectoryName(HiLiTEFile.FullName), m.Groups[1].Value).Replace("\\", "/") }".Trim();
				foreach (string referencedFile in referencedFiles.Split(new char[] { ',', ' ' }, StringSplitOptions.RemoveEmptyEntries))
                {
					// Add extension only for Matlab model:
					if (archive.Entries.FirstOrDefault(e => e.FullName.Equals($"{ referencedFile }.mdl", StringComparison.OrdinalIgnoreCase)) == null
						&& archive.Entries.FirstOrDefault(e => e.FullName.Equals(referencedFile, StringComparison.OrdinalIgnoreCase)) == null)
						throw new Exception($"Configuration { HiLiTEFile.FullName } within { Path.GetFileName(fileName) } archive references { referencedFile }, which is not in the archive.");
				}
				return true;
			}
			return false;
		}

        private static void AddFileWithContent(string fileName, string content, ZipArchive archive)
        {
            using (var entryStream = archive.CreateEntry(fileName).Open())
                using (var streamWriter = new StreamWriter(entryStream))
                {
                    streamWriter.Write(content);
                }
        }
    }
}
