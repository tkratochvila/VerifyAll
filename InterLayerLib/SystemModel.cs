using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Text.RegularExpressions;
using System.Xml;
using System.Xml.XPath;

namespace InterLayerLib
{
    public class SystemModel
    {
        /// The a filenames including a path to the system designs (C/C++/Simulink model .xml)
        public List<string> systemPaths = new List<string>();
        /// The a filename including a path to the system design (C/C++/Simulink model .xml)
        public string systemPath;
        /// The filename of the system design (C/C++/Simulink model .xml)
        public string systemName = "";
        /// the name of the model (parsed from the XML)
        public string modelName;

        /// all variables from the system (model, design, source code)
        public List<String> variables = new List<string>();
        /// blocks from the system (model, design, source code)
        public List<String> blocks = new List<string>();

        public const int NUMBER_OF_INTERFACE_TYPES = 5; // == input, output, internal, parameters and states
        public enum InterfaceTypes
        {
            Inputs = 0,
            Outputs = 1,
            Internals = 2,
            Parameters = 3,
            States = 4
        }
        /// input, output, internal and parameters variables from the system (model, design, source code)
        public List<String>[] interfaceVariables;
        public HashSet<String> inputVariables = new HashSet<string>();
        public HashSet<String> outputVariables = new HashSet<string>();
        public int maximumIdentifierLength = -1; // Maximum length of identifiers in the generated code

        /// Mapping of the input variables (function parameters) to the output variables (function output)
        public Dictionary<int, List<int>> variablesIndexedToMethods { get; set;}
        public Dictionary<string, List<List<string>>> inputsPairedToOutputs;

        /// data types of input, output,  internal and parameters variables from the system (model, design, source code)
        public List<String>[] interfaceVariablesTypes;
        public InterfaceRequirements[] interfaceRequirement; //input, output, internal and parameters interface requirements
        public List<List<string>> allsignals; // all signals names merged together and sorted from longest to shortest.
        /// Collection of all variables that can be auto completed in proposition instantiation phase.
        //public AutoCompleteStringCollection APCollection = new AutoCompleteStringCollection();

        /// list of systemModel.variables from simulink model for each requirement     
        public HashSet<string>[] VariableList;

        public Requirements reqs;

        public List<string>[] uncoveredSignals;
        public List<string>[] uncoveredVariables;
        public List<string> uncoveredImpliedVariables;

        /// all stateflow states from the system (model, design, source code)
        public List<string> StateflowStates = new List<string>();
        /// all Stateflow Charts for a given state from the system (model, design, source code)
        public List<String> StateflowCharts = new List<string>();
        /// all Stateflow names (is it actually a number) the system (model, design, source code)
        public List<String> StateflowNames = new List<string>();

        /// global Sample time of the Simulink model. Time ticks every 1/SimulinkSampleTime seconds
        public double SimulinkSampleTime = -1.0;

        // System model has infinite domain if and only if the model contains infinite data types (real, natural)
        public bool infinite_domain = false;

        public bool systemPathChecked;
        public bool systemPathExists;

        // Simulink models has different suffix that is added to the path generated by Simulink RTW. 
        // The variable contains modelName + the suffix
        // For example: "_ert_rtw", "_ham_C919".
        public string rtwgensettingsBuildDir;
        public string cName; // Name of generated .c file from Simulink
        
        public string variablePartitioning;
        public string ltlFileContent;

        // Databuffer structure for generating memory block which is necessary for handcoded file verification 
        private List<ushort> dataBuffer;

        public Dictionary<string, Dictionary<string, List<string>>> TableRequirements = new Dictionary<string, Dictionary<string, List<string>>>();
        // Dictionary of table captions and table content in the requirements document, where
        // Table content (Dictionary<string, List<string>>) is a dictionary of column headers and the list of remaining column cells.

        public bool bufferBasedHandcoded;

        public SystemModel()
        {
            systemPath = "";
            systemPathChecked = false;

            Debug.Assert(Enum.GetNames(typeof(InterfaceTypes)).Length == NUMBER_OF_INTERFACE_TYPES); // Make sure this is consistent
            interfaceRequirement = new InterfaceRequirements[NUMBER_OF_INTERFACE_TYPES]; // input, output, internal and parameters
            interfaceVariablesTypes = new List<string>[NUMBER_OF_INTERFACE_TYPES];
            interfaceVariables = new List<string>[NUMBER_OF_INTERFACE_TYPES];
            for (int i = 0; i < NUMBER_OF_INTERFACE_TYPES; i++)
            {
                interfaceRequirement[i] = new InterfaceRequirements();
                interfaceVariables[i] = new List<string>();
                interfaceVariablesTypes[i] = new List<string>();
            }
            reqs = new Requirements(systemName);

            variablesIndexedToMethods = new Dictionary<int, List<int>>();
            inputsPairedToOutputs = new Dictionary<string, List<List<string>>>();

            dataBuffer = new List<ushort>();
            bufferBasedHandcoded = false;
        }


        public void FindGeneratedDirectoryAndCFileName(string modelName, string dirName, ref string directory, ref string file)
        {
            try { directory = Directory.GetDirectories(dirName).Where(d => d.StartsWith(Path.Combine(dirName, modelName))).OrderByDescending(dd => new DirectoryInfo(dd).LastAccessTimeUtc).First(); }
            catch { }
            if (directory != null)
            {
                cName = Path.Combine(directory, modelName + "*.c");
                // Make sure that file is not modelName + "_data.c" 
                try { file = Directory.GetFiles(directory).Where(f => f.EndsWith(modelName + ".c") || f.EndsWith(modelName + "_sf.c")).OrderByDescending(f => new FileInfo(f).LastAccessTimeUtc).First(); }
                catch { }
                if (file != null)
                {
                    rtwgensettingsBuildDir = Path.GetFileName(directory.TrimEnd(Path.DirectorySeparatorChar, Path.AltDirectorySeparatorChar));
                    cName = file;
                    systemPaths.Clear();
                    systemPaths.Add(file);
                    updateMaximumIdentifierLength();
                }
            }
        }

        public void CheckForReferencedModel(string fileName, string line)
        {
            if (line.StartsWith("Models referenced:") || line.StartsWith("//Models referenced:") || line.StartsWith("//Source code referenced:"))
            {
                // Open referenced model only if it is not already opened.
                // Rationale: to avoid redundancy parsing of the model.
                line = Regex.Replace(line, "^.* referenced:", "").Replace("\r", "").Replace("\n", "").Trim();
                if (systemName != line)
                {
                    systemName = line;
                    if (systemName.Contains(" "))
                        systemName = systemName.Remove(systemName.IndexOf(" "));
                    if (systemName.IndexOfAny(System.IO.Path.GetInvalidFileNameChars()) != -1)
                        systemName = "";
                    else
                    {
                        systemPath = Path.Combine(Path.GetDirectoryName(fileName), systemName);
                        guessSystemPath();
                        if (!isC()) // If this is not hand-coded C
                        {
                            modelName = Path.GetFileNameWithoutExtension(systemName);
                            //string dirName = Path.Combine(Path.GetDirectoryName(systemPath), ".generatedC", modelName);
                            string dirName = Path.Combine(Path.GetDirectoryName(Path.GetFullPath(systemPath)), ".generatedC", modelName);
                            string file = null;
                            string directory = null;
                            FindGeneratedDirectoryAndCFileName(modelName, dirName, ref directory, ref file);
                        }
                        else // for hand-coded C
                        {
                            systemPaths.Clear();
                            systemPaths.Add(systemPath);
                        }
                        // Store assigned system name into internal ReqIF structure
                        ((XmlElement)reqs.doc.GetElementsByTagName("REQ-IF-HEADER").Item(0)).SetAttribute("ASSIGNED-SYSTEM", systemName);

                        // Fill Reqirements inputs and outputs if not already done from .xml file
                        if (systemPaths.Count() > 0)
                        {
                            if (interfaceVariablesTypes[(int)SystemModel.InterfaceTypes.Inputs].Count == 0 && interfaceVariablesTypes[(int)SystemModel.InterfaceTypes.Outputs].Count == 0 ||
                                interfaceVariables[(int)SystemModel.InterfaceTypes.Inputs].Count == 0 && interfaceVariables[(int)SystemModel.InterfaceTypes.Outputs].Count == 0)
                            {
                                setInterfaceVariablesTypes();
                            }
                        }
                    }
                }
            }
        }

        public void importSystemFromStream(StreamReader sr, string fileName)
        {
            var signal = new List<string>(); //  Signal Name
            string line;
            while ((line = sr.ReadLine()) != null)
            {
                CheckForReferencedModel(fileName, line);
                if (line.StartsWith("//.inputs") || line.StartsWith("//.outputs") || line.StartsWith("//.internals"))
                {
                    int irindex;
                    if (line.StartsWith("//.inputs")) irindex = 0;
                    else if (line.StartsWith("//.outputs")) irindex = 1;
                    else irindex = 2;
                    interfaceRequirement[irindex].sr.Add(new SignalRepresenations(0, "Signal Name"));
                    foreach (string s in line.Remove(0, line.IndexOf('s') + 1).Trim().Split(' '))
                    {
                        signal = new List<string>();
                        signal.Add(s);
                        if (!interfaceRequirement[irindex].signals.Any(sig => sig.Any(s1 => s1 == s))) // Add only distinct signals
                        {
                            interfaceRequirement[irindex].signals.Add(signal);
                        }
                    }
                    interfaceRequirement[irindex].SignalNameIndex = 0;
                    interfaceRequirement[irindex].TextualRepresentationIndex = 0;
                }
            }
        }

        /// <summary>
        /// Reads and parse the file generated by Simulink to fill the SystemModel's
        /// input and output variable arrays. File has fixed structure used by the parser.
        /// </summary>
        private void GetVariablesFromSimulinkFile()
        {
            using (StreamReader fileReader = new StreamReader(Path.ChangeExtension(systemPaths[0], ".h")))
            {
                bool[] InterfaceTypeFound = new bool[NUMBER_OF_INTERFACE_TYPES];
                for (int i = 0; i < NUMBER_OF_INTERFACE_TYPES; i++)
                    InterfaceTypeFound[i] = false;
                string line = "";
                while (InterfaceTypeFound.Any(x=>!x) && !fileReader.EndOfStream)
                {
                    line = fileReader.ReadLine();
                    if (line.StartsWith("/* "))
                    {
                        if (line.StartsWith("/* External inputs"))  // Auto generated Simulink .h files starts input variable section with this line
                        {
                            InterfaceTypeFound[(int)InterfaceTypes.Inputs] = getVariablesAndDataTypesFromStruct(fileReader, (int)InterfaceTypes.Inputs, ref line);
                        }
                        else if (line.StartsWith("/* External outputs"))
                        {
                            InterfaceTypeFound[(int)InterfaceTypes.Outputs] = getVariablesAndDataTypesFromStruct(fileReader, (int)InterfaceTypes.Outputs, ref line);
                        }
                        else if (line.StartsWith("/* Block signals"))
                        {
                            InterfaceTypeFound[(int)InterfaceTypes.Internals] = getVariablesAndDataTypesFromStruct(fileReader, (int)InterfaceTypes.Internals, ref line);
                        }
                        else if (line.StartsWith("/* Parameters "))
                        {
                            InterfaceTypeFound[(int)InterfaceTypes.Parameters] = getVariablesAndDataTypesFromStruct(fileReader, (int)InterfaceTypes.Parameters, ref line);
                        }
                        else if (line.StartsWith("/* Block states "))
                        {
                            InterfaceTypeFound[(int)InterfaceTypes.States] = getVariablesAndDataTypesFromStruct(fileReader, (int)InterfaceTypes.States, ref line);
                        }
                    }
                }
            }
        }

        private bool getVariablesAndDataTypesFromStruct(StreamReader fileReader, int interfaceType, ref string line)
        {
            line = fileReader.ReadLine();
            if (line.Contains("struct ") && line.Trim().EndsWith("{"))   // Read line called one time to load up struct declaration
            {
                line = fileReader.ReadLine();
                while (!line.Trim().StartsWith("}"))    // End line of input variables struct
                {
                    while (line.Trim().StartsWith("*") || line.Trim() == "") // skip multi-line comments
                    {
                        line = fileReader.ReadLine();
                    }
                    if (line.Trim().StartsWith("}"))
                    {
                        return true;
                    }
                    if (interfaceVariablesTypes[interfaceType].Count < interfaceVariables[interfaceType].Count()) // Check which of the variable related information is missing - type/name/both
                    {
                        interfaceVariablesTypes[interfaceType].Add(line.Remove(line.IndexOf("_T ") + 2).Trim());  // Skip two white spaces and copy substring containing variable type
                    }
                    else if (interfaceVariablesTypes[interfaceType].Count > interfaceVariables[interfaceType].Count())
                    {
                        interfaceVariables[interfaceType].Add(Regex.Replace(line, @"\s+[a-z0-9A-Z_]+\s+([a-zA-Z_0-9\[\]]+)\s*;.*", "$1"));
                    }
                    else
                    {
                        interfaceVariablesTypes[interfaceType].Add(line.Remove(line.IndexOf("_T ") + 2).Trim());  // Skip two white spaces and copy substring containing variable type
                        interfaceVariables[interfaceType].Add(Regex.Replace(line, @"\s+[a-z0-9A-Z_]+\s+([a-zA-Z_0-9\[\]]+)\s*;.*", "$1"));
                    }
                    line = fileReader.ReadLine();
                }
                return true;
            }
            return false;
        }

        /// <summary>
        /// Parse and store the information related to input variables
        /// from the hancoded C/C++ file.
        /// </summary>
        /// <param name="line">Reference to the line of code read from the header file.</param>
        void ParseInputs(ref string line)
        {
            int inputTypeIndex = line.IndexOf('(') + 1;
            string inputs = line.Substring(inputTypeIndex).Trim();
            if (!inputs.Contains("void"))
            {
                while (inputs.Length > 0)
                {
                    string prefix = interfaceVariables[(int)InterfaceTypes.Outputs][interfaceVariables[(int)InterfaceTypes.Outputs].Count - 1] + "_";
                    inputs.Trim();
                    int position = inputs.IndexOf(' ');
                    interfaceVariablesTypes[(int)InterfaceTypes.Inputs].Add(inputs.Substring(0, position).Trim());
                    position++;
                    inputs = inputs.Substring(position);
                    position = inputs.IndexOf(", ");
                    if (position != -1) // Test the end of the function
                    {
                        if (inputs.Substring(0, position).Contains("[]"))
                        {
                            // Add the information about the array to variable type
                            interfaceVariablesTypes[(int)InterfaceTypes.Inputs][interfaceVariablesTypes[(int)InterfaceTypes.Inputs].Count - 1] += "[]";
                        }
                        if (inputs.Substring(0, position).Contains('*'))
                        {
                            // Add the information about the pointer to variable type
                            interfaceVariablesTypes[(int)InterfaceTypes.Inputs][interfaceVariablesTypes[(int)InterfaceTypes.Inputs].Count - 1] += "*";
                        }
                        interfaceVariables[(int)InterfaceTypes.Inputs].Add(prefix + inputs.Substring(0, position).Trim('*', ' '));
                        variablesIndexedToMethods[interfaceVariables[(int)InterfaceTypes.Outputs].Count - 1].Add(interfaceVariables[(int)InterfaceTypes.Inputs].Count - 1);
                        position += 2;  // Skip the method input variable separator ", "
                    }
                    else
                    {
                        position = inputs.IndexOf(')');
                        if (inputs.Substring(0, position).Contains("[]"))
                        {
                            // Add the information about the array to variable type
                            interfaceVariablesTypes[(int)InterfaceTypes.Inputs][interfaceVariablesTypes[(int)InterfaceTypes.Inputs].Count - 1] += "[]";
                        }
                        if (inputs.Substring(0, position).Contains('*'))
                        {
                            // Add the information about the pointer to variable type
                            interfaceVariablesTypes[(int)InterfaceTypes.Inputs][interfaceVariablesTypes[(int)InterfaceTypes.Inputs].Count - 1] += "*";
                        }
                        interfaceVariables[(int)InterfaceTypes.Inputs].Add(prefix + inputs.Substring(0, position).Trim('*', ' '));
                        variablesIndexedToMethods[interfaceVariables[(int)InterfaceTypes.Outputs].Count - 1].Add(interfaceVariables[(int)InterfaceTypes.Inputs].Count - 1);
                        position++;  // Skip the last character of string ")"
                    }
                    inputs = inputs.Substring(position);
                }
            }
        }

        /// <summary>
        /// Parse and store the information related to output variables
        /// from the hancoded C/C++ file.
        /// </summary>
        /// <param name="line">Reference to the line of code read from the header file.</param>
        void ParseOutputs(ref string line)
        {
            line.TrimStart();   // Remove white spaces from the function declaration begining
            if (!line.StartsWith("void"))
            {
                int outputTypeIndex = line.IndexOf(' ');
                interfaceVariablesTypes[(int)InterfaceTypes.Outputs].Add(line.Substring(0, outputTypeIndex));
                int outputNameIndex = line.IndexOf('(');
                outputTypeIndex++;  // outputTypeIndex + 1 to skip the white space
                interfaceVariables[(int)InterfaceTypes.Outputs].Add(line.Substring(outputTypeIndex, outputNameIndex - outputTypeIndex));
                variablesIndexedToMethods.Add(interfaceVariables[(int)InterfaceTypes.Outputs].Count  - 1, new List<int>());
                if (line.Substring(outputTypeIndex, outputNameIndex - outputTypeIndex).Contains("[]"))
                {
                    // Add the information about the array to variable type
                    interfaceVariablesTypes[(int)InterfaceTypes.Outputs][interfaceVariablesTypes[(int)InterfaceTypes.Outputs].Count - 1] += "[]";
                }
                if (line.Substring(outputTypeIndex, outputNameIndex - outputTypeIndex).Contains("*"))
                {
                    // Add the information about the pointer to variable type
                    interfaceVariablesTypes[(int)InterfaceTypes.Outputs][interfaceVariablesTypes[(int)InterfaceTypes.Outputs].Count - 1] += "*";
                }
            }
        }

        /// <summary>
        /// Method parses inputs from requirements ".EARS" file.
        /// These are introduced by the "//.inputs" string.
        /// </summary>
        /// <param name="inputs"></param>
        void ParseInputsFromEARS(string inputs)
        {
            string functionInputs = inputs.Substring(inputs.IndexOf(' ') + 1);
            List<string> EARSInputs = functionInputs.Split(' ').ToList();
            foreach(var item in EARSInputs)
            {
                // Extract the input variable info - the name and the type.
                string[] inputInfo = item.Split('(').ToArray();
                interfaceVariables[(int)InterfaceTypes.Inputs].Add(inputInfo[0]);
                string inputType = inputInfo[1].Substring(0, inputInfo[1].Length - 1);  // -1 to remove the char of ending bracket ')' defining the types in EARS file
                interfaceVariablesTypes[(int)InterfaceTypes.Inputs].Add(inputType);
            }
        }

        /// <summary>
        /// Method parses outputs from the requirements ".EARS" file.
        /// These are introduced by the "//.outputs" string.
        /// </summary>
        /// <param name="outputs"></param>
        void ParseOutputsFromEARS(string outputs)
        {
            string functionOutputs = outputs.Substring(outputs.IndexOf(' ') + 1);
            List<string> EARSOutputs = functionOutputs.Split(' ').ToList();
            foreach (var item in EARSOutputs)
            {
                // Extract the output variable info - the name and the type.
                string[] outputInfo = item.Split('(').ToArray();
                interfaceVariables[(int)InterfaceTypes.Outputs].Add(outputInfo[0]);
                string outputType = outputInfo[1].Substring(0, outputInfo[1].Length - 1);  // -1 to remove the char of ending bracket ')' defining the types in EARS file
                interfaceVariablesTypes[(int)InterfaceTypes.Outputs].Add(outputType);
            }
        }

        /// <summary>
        /// Formalize data types to the format used by tools (probably comes from Simulink???)
        /// TODO is necesarry to add other data types.
        /// </summary>
        /// <param name="dataType"></param>
        /// <returns></returns>
        string formalizeDataType(string dataType)
        {
            string formalizedDataType = "";

            switch (dataType)
            {
                case "int32":
                    formalizedDataType = "int32_T";
                    break;
                case "bool":
                    formalizedDataType = "bool_T";
                    break;
                case "float":
                    formalizedDataType = "real32_T";
                    break;
                default:
                    break;
            }

            return formalizedDataType;
        }

        /// <summary>
        /// TODO multiple same outputs cause problems - do we need this functionality is it allowed in the system???
        /// Method pairs inputs to their belonging output.
        /// In case of variables with same name but different data type
        /// </summary>
        /// <param name="requirements"></param>
        void PairIOVariables(string requirements)
        {
            List<string> parsedRequirements = requirements.Split(new[] { "ID" }, StringSplitOptions.RemoveEmptyEntries).ToList();
            int reqCount = reqs.Count;

            // use instead variablesindexedtomethods
            Dictionary<string, List<string>> pairedIOs = new Dictionary<string, List<string>>();
            foreach (var requirement in parsedRequirements)
            {
                foreach(var output in interfaceVariables[(int)InterfaceTypes.Outputs])
                {
                    if (requirement.Contains(output))
                    {
                        if (!inputsPairedToOutputs.ContainsKey(output))
                        {
                            inputsPairedToOutputs.Add(output, new List<List<string>>());
                        }
                        inputsPairedToOutputs[output].Add(new List<string>());
                        foreach (var input in interfaceVariables[(int)InterfaceTypes.Inputs])
                        {
                            if (requirement.Contains(input))
                            {
                                inputsPairedToOutputs[output][inputsPairedToOutputs[output].Count - 1].Add(input);
                            }
                        }
                    }
                }
            }
        }

        void GetBufferedVariablesFromHandcodedFile()
        {
            if (File.Exists(systemPaths[0]))
            {
                //string directoryName = Path.Combine(Path.GetDirectoryName(systemPaths[0]), ".generatedC") + "\\" + Path.GetFileNameWithoutExtension(systemPaths[0]);
                string directoryName = Path.Combine(Path.GetDirectoryName(Path.GetFullPath(systemPaths[0])), ".generatedC") + "\\" + Path.GetFileNameWithoutExtension(systemPaths[0]);
                System.IO.Directory.CreateDirectory(directoryName);
                string fileName = Path.Combine(directoryName, Path.GetFileName(systemPaths[0]));
                if (File.Exists(fileName))
                {
                    File.SetAttributes(fileName, FileAttributes.Normal);    // It is not possible to overwrite file when this is "read-only", so we need to change it.
                }
                System.IO.File.Copy(systemPaths[0], fileName, true);
                cName = fileName;
                File.SetAttributes(fileName, FileAttributes.Normal);    // File atributes must be changed from "read-only" again to allow editing.

                using (StreamReader fileReader = new StreamReader(reqs.RequirementDocumentFilename))
                {
                    string line = "";
                    string requirements = "";
                    while (!fileReader.EndOfStream)
                    {
                        line = fileReader.ReadLine();

                        if (line.StartsWith("//.inputs"))
                        {
                            ParseInputsFromEARS(line);
                        }
                        else if (line.StartsWith("//.outputs"))
                        {
                            ParseOutputsFromEARS(line);
                        }
                        else
                        {
                            requirements += line + Environment.NewLine;
                        }
                    }
                    PairIOVariables(requirements);
                }
            }
            else
            {
                //MessageBox.Show("Requested file does not exist.");
            }
        }

        /// <summary>
        /// Reads and parse the handcoded C file to fill the SystemModel's
        /// input and output variable arrays.
        /// </summary>
        private void GetVariablesFromHandcodedFile()
        {
            if (File.Exists(systemPaths[0]))
            {
                string directoryName = Path.Combine(Path.GetDirectoryName(Path.GetFullPath(systemPaths[0])), ".generatedC") + "\\" + Path.GetFileNameWithoutExtension(systemPaths[0]);
                System.IO.Directory.CreateDirectory(directoryName);
                string fileName = Path.Combine(directoryName, Path.GetFileName(systemPaths[0]));
                if (File.Exists(fileName))
                {
                    File.SetAttributes(fileName, FileAttributes.Normal);    // It is not possible to overwrite file when this is "read-only", so we need to change it.
                }
                System.IO.File.Copy(systemPaths[0], fileName, true);
                cName = fileName;
                File.SetAttributes(fileName, FileAttributes.Normal);    // File atributes must be changed from "read-only" again to allow editing.
                using (StreamReader fileReader = new StreamReader(systemPaths[0]))
                {
                    string line = "";

                    while (!fileReader.EndOfStream)
                    {
                        line = fileReader.ReadLine().TrimEnd();

                        if (line.Contains("("))
                        {
                            if (!line.StartsWith("*") && !line.StartsWith(" ") && !line.StartsWith("#") && !line.StartsWith("\t"))//TODO - weak spot functions must start in c file at col 1, solve by Trim?
                            {
                                // If the function declaration is done on just by one line.
                                if (line.EndsWith(")"))
                                {
                                    // Find out output varible types and names
                                    ParseOutputs(ref line);

                                    // Find out input variable types and names
                                    ParseInputs(ref line);
                                }
                                else
                                {
                                    // If the function declaration is done on multiple lines.
                                    while(!line.Contains(")"))
                                    {
                                        line += fileReader.ReadLine();
                                    }

                                    // Find out output varible types and names
                                    ParseOutputs(ref line);

                                    // Find out input variable types and names
                                    ParseInputs(ref line);
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                //MessageBox.Show("Requested file does not exist.");
            }
        }

        /// <summary>
        /// Check if .c file is using the code for generating data and routing buffer.
        /// </summary>
        /// <returns></returns>
        bool IsUsingDataBuffer()
        {
            using (StreamReader fileReader = new StreamReader(systemPath))
            {
                string line = "";

                while (!fileReader.EndOfStream)
                {
                    line = fileReader.ReadLine();
                    if (line == "void buildDataBuffer(void** IO_Buf_ptr, void** block_routing_ptr, void* functionPtr)")
                    {
                        bufferBasedHandcoded = true;
                        return true;
                    }
                }
            }

            return false;
        }

        /// <summary>
        /// Method decides if input and output variables are going to be loaded from
        /// simulink generated header or C/C++ handcoded file.
        /// </summary>
        public void setInterfaceVariablesTypes()
        {
            if (isC())
            {
                if (IsUsingDataBuffer())
                {
                    GetBufferedVariablesFromHandcodedFile();
                }
                else
                {
                    GetVariablesFromHandcodedFile();
                }
            }
            else
            {
                GetVariablesFromSimulinkFile();
            }
        }

        public Dictionary<string, InputFile> buildSystemFiles(string LocalUserAppDataPath)
        {
            Dictionary<string, InputFile> files = new Dictionary<string, InputFile>();
            
            if (exists())
            {
                // Also copy all existing included files recursively for all systempaths
                Queue<string> sourceCodesToProcess = new Queue<string>();
                HashSet<string> alreadyProcessesedSourceCodes = new HashSet<string>();
                files.Add("main-", new InputFile(cName));
                foreach (string path in systemPaths)
                {
                    sourceCodesToProcess.Enqueue(path);
                }
                string currentSourceCode;
                while (sourceCodesToProcess.Count > 0)
                {
                    currentSourceCode = sourceCodesToProcess.Dequeue();
                    if (alreadyProcessesedSourceCodes.Contains(currentSourceCode))
                        continue;
                    if (File.Exists(currentSourceCode))
                        using (StreamReader reader = File.OpenText(currentSourceCode))
                        {
                            string line;
                            while ((line = reader.ReadLine()) != null)
                                if (new Regex("^#include \"").IsMatch(line))
                                {
                                    line = Path.Combine(Path.GetDirectoryName(currentSourceCode), 
                                        line.Replace("#include ", "").Replace("\"", "")); // TODO remove comments first.
                                    if (!alreadyProcessesedSourceCodes.Contains(line) && !sourceCodesToProcess.Contains(line))
                                    {
                                        if (File.Exists(line))
                                        {
                                            sourceCodesToProcess.Enqueue(line);
                                            files.Add("header" + line, new InputFile(line));
                                        }
                                        // Ignore divine.h and dios.h since this is included in DIVINE
                                        else if (Path.GetFileName(line) != "divine.h"
                                            && Path.GetFileName(line) != "assert.h"
                                            && Path.GetFileName(line) != "dios.h"
                                            && Path.GetFileName(line) != "math.h"
                                            && Path.GetFileName(line) != "stdbool.h")
                                            files.Add("Missing-source-code" + files.Count(), new InputFile(line));
                                    }
                                }
                        }
                    alreadyProcessesedSourceCodes.Add(currentSourceCode);
                }
            }
            else
            {
                files["requirements"] = new InputFile(Path.Combine(Directory.GetCurrentDirectory(), "requirements.ltl"));
                files["variablePartitioning"] = new InputFile(Path.Combine(Directory.GetCurrentDirectory(), "requirements.part"));
                files["SMT"] = new InputFile(Path.Combine(LocalUserAppDataPath, "requirements.temp"));
            }
            return files;
        }

        /// <summary>
        /// If the system path is not valid absolute path.
        /// Try to find the system file in either requirement document path or in client path.
        /// </summary>
        public void guessSystemPath()
        {
            if (File.Exists(systemPath))
                return;

            systemPath = systemName;
            // Unify the slash and backslash
            systemPath.Replace("/", "\\");
            string RequirementDocumentPath = "";
            if (reqs.RequirementDocumentFilename.Contains('\\'))
                RequirementDocumentPath = Path.GetDirectoryName(reqs.RequirementDocumentFilename);
            // If the filename is provided but not its path
            if (!systemPath.Contains("\\"))
            {
                // try to guess the path of the system by finding the system
                string guessedPath;
                if (File.Exists(guessedPath = Path.Combine(RequirementDocumentPath, systemPath)))
                    systemPath = guessedPath;
                else if (File.Exists(guessedPath = Path.Combine(Directory.GetCurrentDirectory(), systemPath)))
                    systemPath = guessedPath; 
            }
            else // when absolute path to the system is provided
                systemName = Path.GetFileName(systemPath);
        }

        public bool exists()
        {
            if (!systemPathChecked)
            {
                systemPathChecked = true;
                systemPathExists = File.Exists(systemPath);
            }
            return systemPathExists;
        }

        public void deleteIfEmpty()
        {
            if (!exists())
                return;
            // Delete the XML file if the file is empty (due to an error in 3ser execution)
            FileInfo fInfo = new FileInfo(systemPath);
            if (fInfo.Length == 0)
            {
                File.Delete(systemPath);
                systemPathChecked = false;
                //MessageBox.Show("The XML file: " + systempath + " had 0 size and was deleted.");
            }
            // Leave the function if the XML is not readable
            if (!readSimulinkXML())
                return;
        }

        /// <summary>
        /// Reads the given Simulink xml file to internal xml document. Moreover reads the Simulink variables.
        /// </summary>
        /// <returns>true iff the Simulink XML read was successful.</returns>
        public bool readSimulinkXML()
        {
            if (isSimulinkXMLCorrect(Path.ChangeExtension(systemPath,".xml")))
            {
                try
                {
                    XmlDocument systemdoc = new XmlDocument();
                    systemdoc.Load(Path.ChangeExtension(systemPath,".xml"));
                    XmlNode model = systemdoc.DocumentElement;

                    modelName = model.Attributes.GetNamedItem("name").Value;
                    variables.Clear();
                    for (int i = 0; i < NUMBER_OF_INTERFACE_TYPES; i++)
                    {
                        interfaceVariables[i].Clear();
                        interfaceVariablesTypes[i].Clear();
                    }

                    StateflowStates.Clear();
                    StateflowNames.Clear();
                    StateflowCharts.Clear();
                    
                    var compiledDataTypes = new List<Tuple<string, string>>();
                    compiledDataTypes = loadCompiledDataType(compiledDataTypes);

                    recursivelyReadXML(model, compiledDataTypes);
                    addExternalInportssOutportsToVariables(model, compiledDataTypes);

                    for (int i = 0; i < NUMBER_OF_INTERFACE_TYPES; i++)
                        variables.AddRange(interfaceVariables[i]);

                    foreach (string state in StateflowStates)
                        variables.Add("in_" + state);

                    //APCollection.Clear();
                    // TODO add states in the form "in(state)" for Stateflow models
                    /*foreach (string variable in variables)
                        APCollection.Add(variable);*/
                }
                catch
                {
                    //MessageBox.Show(${ Path.ChangeExtension(systempath,".xml") }:{ Environment.NewLine }{ ex.Message }", "Unable to process the XML system design.");
                    return false;
                }
                return true;
            }
            return false;
        }
        /// <summary>
        /// Detect if the Simulink XML seems to be correct
        /// </summary>
        /// <param name="path">Path to the XML Simulink model.</param>
        /// <returns>true iff the XML is correct</returns>
        public bool isSimulinkXMLCorrect(string path)
        {
            if (!File.Exists(path))
                return false;
            try
            {
                XmlDocument systemdoc = new XmlDocument();
                systemdoc.Load(path);
                XmlNode model = systemdoc.DocumentElement;
                /*if (model.Name != "hon:Model")
                {
                    MessageBox.Show("The system does not contain the root element named: <hon:Model>." + Environment.NewLine + Environment.NewLine +
                        path + ":" + Environment.NewLine + systemdoc.OuterXml, "Unable to read the system");
                    path = "";
                    return false;
                }*/

                /*if (model.Attributes.GetNamedItem("name").Value == null)
                {
                    MessageBox.Show("The root element does not contain attribute named: name." + Environment.NewLine + Environment.NewLine +
                        path + ":" + Environment.NewLine + systemdoc.OuterXml, "Unable to read the system");
                    return false;
                }*/
            }
            catch //(Exception e)
            {
                return false;
            }
            return true;
        }

        public void openSystem()
        {
            systemPathChecked = false;
            systemName = Path.GetFileName(systemPath);
            // Store assigned system name into internal ReqIF structure
            ((XmlElement)reqs.doc.GetElementsByTagName("REQ-IF-HEADER").Item(0)).SetAttribute("ASSIGNED-SYSTEM", systemName);
            blocks.RemoveRange(0, blocks.Count);
            variables.RemoveRange(0, variables.Count);
            for (int i = 0; i < NUMBER_OF_INTERFACE_TYPES; i++)
            {
                interfaceVariables[i].RemoveRange(0, interfaceVariables[i].Count);
                interfaceVariablesTypes[i].RemoveRange(0, interfaceVariablesTypes[i].Count);
            }
            SimulinkSampleTime = -1.0;
        }
        /// <summary>
        /// Adds externally visible inports and outports (shall have hon:Syntax as a parent) to variables
        /// </summary>
        private void addExternalInportssOutportsToVariables(XmlNode model, List<Tuple<string, string>> compiledDataTypes)
        {
            XmlNode Syntax = null;
            string children = "";
            string datatype = "unknown";
            foreach (XmlNode child in model.ChildNodes)
            {
                children += "<" + child.Name + ">, ";
                if (child.Name == "hon:Syntax")
                    Syntax = child;
            }
            //if (Syntax == null)
            //    MessageBox.Show("One child of root element (<hon:Model>) is expected to be: <hon:Syntax>." + Environment.NewLine + "However there are just these children: " + children + " instead.", "Unexpected structure of the Simulink model.");
            foreach (XmlNode node in Syntax.ChildNodes)
            {
                if (node.Name == "hon:SimulinkInport")
                {
                    interfaceVariables[(int)SystemModel.InterfaceTypes.Inputs].Add(node.Attributes.GetNamedItem("name").Value);
                    if (compiledDataTypes.Any(x => x.Item1.Contains(node.Attributes.GetNamedItem("name").Value)))
                        datatype = compiledDataTypes.Single(x => x.Item1 == node.Attributes.GetNamedItem("name").Value).Item2;
                    if (datatype != "unknown")
                        interfaceVariablesTypes[(int)SystemModel.InterfaceTypes.Inputs].Add(datatype);
                }
                else if (node.Name == "hon:SimulinkOutport")
                {
                    interfaceVariables[(int)SystemModel.InterfaceTypes.Outputs].Add(node.Attributes.GetNamedItem("name").Value);
                    if (compiledDataTypes.Any(x => x.Item1.Contains(node.Attributes.GetNamedItem("name").Value)))
                        datatype = compiledDataTypes.Single(x => x.Item1 == node.Attributes.GetNamedItem("name").Value).Item2;
                    if (datatype != "unknown")
                        interfaceVariablesTypes[(int)SystemModel.InterfaceTypes.Outputs].Add(datatype);
                }
            }
            foreach (var i in interfaceVariables[(int)SystemModel.InterfaceTypes.Inputs]) inputVariables.Add(i);
            foreach (var i in interfaceVariables[(int)SystemModel.InterfaceTypes.Outputs]) outputVariables.Add(i);
        }

        /// <summary>
        /// Add all the inports or outports to the internal variables (block name could be either name or its name combined with its parent subsystem name: "subsystem_block").
        /// </summary>
        public void addInportOrOutportToVariables(XmlNode node, List<Tuple<string, string>> compiledDataTypes)
        {
            string datatype = "unknown";
            foreach (XmlNode subnode in node.ChildNodes)
            {
                string type = subnode.Attributes.GetNamedItem("type").Value;
                Debug.Assert(subnode.Name == "hon:SimulinkPort", "Error in XML file." + Environment.NewLine +
                    "Expected subnode name: hon:SimulinkPort" + Environment.NewLine + "Actual subnode name:" + subnode.Name);
                Debug.Assert(type == "input" || type == "output", "Error in XML file." + Environment.NewLine +
                    "Expected subnode type: input/outpout" + Environment.NewLine + "Actual subnode type:" + type);
                XmlNode parent = node.ParentNode;
                string full_name = node.Attributes.GetNamedItem("name").Value;
                while (parent.Name == "hon:SimulinkSubSystem")
                {
                    full_name = parent.Attributes.GetNamedItem("name").Value + "/" + full_name;
                    parent = parent.ParentNode;
                }
                interfaceVariables[(int)SystemModel.InterfaceTypes.Internals].Add(Regex.Replace(full_name, "/", "__")); // TODO this might no longer correspond to CESMI syntax
                // TODO Add also block parameters (for example DeadZone.lowervalue will get constant directly or from HAM parent subsystem)
                if (compiledDataTypes.Any(x => x.Item1.Contains(full_name)))
                    datatype = compiledDataTypes.Single(x => x.Item1 == full_name).Item2;
                if (datatype != "unknown")
                    interfaceVariablesTypes[(int)SystemModel.InterfaceTypes.Internals].Add(datatype);
            }
        }

        /// <summary>
        /// Loads all data type for all block names into a list
        /// </summary>
        /// <returns></returns>
        private List<Tuple<string, string>> loadCompiledDataType(List<Tuple<string, string>> compiledDataTypes)
        {
            string filename = Path.ChangeExtension(systemPath, ".DataTypes.xml");
            string blockValueBase = Path.GetFileNameWithoutExtension(systemName) + "/";
            Debug.Assert(compiledDataTypes.Count == 0);
            string datatype;
            infinite_domain = false;

            if (File.Exists(filename))
            {
                foreach (XPathNavigator block in (new XPathDocument(filename)).CreateNavigator().Select("//block"))
                {
                    if (block.Value.Length > systemName.Length - 2)
                    {
                        datatype = block.SelectSingleNode("../params").Value;
                        if (datatype.Contains("int") || datatype.Contains("double"))
                            infinite_domain = true;
                        compiledDataTypes.Add(new Tuple<string, string>(block.Value.Substring(systemName.Length - 3), datatype));
                    }
                }
            }
            return compiledDataTypes;
        }

        /// <summary>
        /// Detect all Simulink variables and Stateflow states among the children of the given node recursively.
        /// </summary>
        private void recursivelyReadXML(XmlNode node, List<Tuple<string, string>> compiledDataTypes)
        {
            foreach (XmlNode subnode in node.ChildNodes)
            {
                recursivelyReadXML(subnode, compiledDataTypes);
                if (subnode.Name == "hon:StateflowState")
                {
                    if (subnode.Attributes.GetNamedItem("labelstring") != null)
                    {
                        XmlNode parent = subnode.ParentNode;
                        string label = subnode.Attributes.GetNamedItem("labelstring").Value.ToString();
                        if (label.Contains("\\n")) label = label.Remove(label.IndexOf("\\n"));
                        string parentLabel = "", SFmodelName = "", firstOutput = "";
                        // Track all ancestors while stateflow chart (hon:SimulinkSubSystem) is not reached (or the root element is not reached in the worst case)
                        while (parent != parent.OwnerDocument.DocumentElement && parent.Name != "hon:SimulinkSubSystem")
                        {
                            // If the parent is a state make it a part of the child name.
                            if (parent.Attributes.GetNamedItem("labelstring") != null)
                            {
                                parentLabel = parent.Attributes.GetNamedItem("labelstring").Value.ToString();
                                if (parentLabel.Contains("\\n")) parentLabel = parentLabel.Remove(parentLabel.IndexOf("\\n"));
                                label = parentLabel + "__" + label;
                            }
                            parent = parent.ParentNode;
                            if (parent.Name == "hon:Model")
                            {
                                SFmodelName = parent.Attributes.GetNamedItem("name").Value.ToString();
                                // Find the first Stateflow output for the given Stateflow model
                                firstOutput = findTheFirstStateflowOutput(parent);
                            }
                        }

                        // Add Model name and Stateflow subsystem name.
                        StateflowStates.Add(parent.Attributes.GetNamedItem("name").Value.ToString() + "_" + label);
                        // The StateflowCharts contains link to the parent chart. For example: Chart__SFunction.currentState;
                        StateflowCharts.Add(parent.Attributes.GetNamedItem("name").Value.ToString() + "__" + SFmodelName);
                        StateflowNames.Add(subnode.Attributes.GetNamedItem("name").Value.ToString());
                    }
                }
                if (node.Name.StartsWith("hon:Simulink") && node.Name != "hon:SimulinkSFunction")
                {
                    string block = node.Attributes.GetNamedItem("name").Value; // name of the block
                    if (node.Name == "hon:SimulinkSubSystem") // All the HAM blocks (except of inport and outport) are masked by a subsystem
                    {
                        if (block == "sampleTime" && node.Attributes.GetNamedItem("maskvariables").Value == "Ts=@1;") // Detect global sample time of the model.
                        {
                            string Ts = node.Attributes.GetNamedItem("maskvaluestring").Value;
                            if (Ts.Substring(0, 2) == "1/")
                            {
                                Double.TryParse(Ts.Substring(2, Ts.Length - 2), out SimulinkSampleTime);
                            }
                        }
                    }
                    if (subnode.Name == "hon:SimulinkInport" || subnode.Name == "hon:SimulinkOutport")
                        addInportOrOutportToVariables(subnode, compiledDataTypes);
                }
            }
        }

        /// <summary>
        /// // Find the first Stateflow output for the given Stateflow model recursively
        /// </summary>
        private string findTheFirstStateflowOutput(XmlNode node)
        {
            foreach (XmlNode subnode in node.ChildNodes)
            {
                if (subnode.Name == "hon:Syntax")
                {
                    foreach (XmlNode subsubnode in subnode.ChildNodes)
                    {
                        if (subsubnode.Name == "hon:StateflowState")
                        {
                            foreach (XmlNode dataNode in subsubnode.ChildNodes)
                            {
                                if (dataNode.Name == "hon:StateflowData" && dataNode.Attributes.GetNamedItem("scope").Value.ToString() == "OUTPUT_DATA")
                                {
                                    return dataNode.Attributes.GetNamedItem("dataname").Value.ToString();
                                }
                            }
                        }
                    }
                }
            }
            return "Error";
        }

        public string prune_variables(HashSet<string> inputs, HashSet<string> outputs, HashSet<string> valids)
        {
            HashSet<string> validInputs = inputs;
            validInputs.IntersectWith(valids);
            String newPartitioning = ".inputs";
            foreach (var s in validInputs)
                newPartitioning += " " + s;
            newPartitioning += Environment.NewLine + ".outputs";
            foreach (var s in outputs)
                if (valids.Contains(s))
                        newPartitioning += " " + s;
            return newPartitioning;
        }

        public HashSet<string> list_used_variables()
        {
            Stopwatch sw0 = new Stopwatch();
            sw0.Start();
            HashSet<string> list = new HashSet<string>();

            int start;
            for (int i = 0; i < ltlFileContent.Count();)
            {
                char c = ltlFileContent[i];
                if (Char.IsLower(c))
                {
                    start = i;
                    while (char.IsLetterOrDigit(c) || c == '_')
                        c = ltlFileContent[++i];                        
                    list.Add(ltlFileContent.Substring(start, i - start));
                }
                else
                    i++;
            }
            sw0.Stop();
            return list;
        }

        public string generateVariables()
        {
            string listOfVariables = "";
            foreach (string variable in interfaceVariables[(int)SystemModel.InterfaceTypes.Inputs])
                if (interfaceVariables[(int)SystemModel.InterfaceTypes.Inputs].Count == interfaceVariablesTypes[(int)SystemModel.InterfaceTypes.Inputs].Count)
                    listOfVariables += "inport\t(" + interfaceVariablesTypes[(int)SystemModel.InterfaceTypes.Inputs][interfaceVariables[(int)SystemModel.InterfaceTypes.Inputs].IndexOf(variable)] + ")\t" + variable + Environment.NewLine;
                else
                    listOfVariables += "inport\t" + variable + Environment.NewLine;

            foreach (string variable in interfaceVariables[(int)SystemModel.InterfaceTypes.Outputs])
                if (interfaceVariables[(int)SystemModel.InterfaceTypes.Outputs].Count == interfaceVariablesTypes[(int)SystemModel.InterfaceTypes.Outputs].Count)
                    listOfVariables += "outport\t(" + interfaceVariablesTypes[(int)SystemModel.InterfaceTypes.Outputs][interfaceVariables[(int)SystemModel.InterfaceTypes.Outputs].IndexOf(variable)] + ")\t" + variable + Environment.NewLine;
                else
                    listOfVariables += "outport\t" + variable + Environment.NewLine;

            foreach (string variable in StateflowStates)
                listOfVariables += "state\t" + variable + Environment.NewLine;

            foreach (string variable in interfaceVariables[(int)SystemModel.InterfaceTypes.Internals])
                listOfVariables += "internal\t" + variable + Environment.NewLine;

            return listOfVariables;
        }

        public string getStateflowNames(string variable)
        {
            return StateflowNames[StateflowStates.IndexOf(variable)];
        }
        public string getStateflowCharts(string variable)
        {
            return StateflowCharts[StateflowStates.IndexOf(variable)];
        }

        public int sumVariables()
        {
            return interfaceVariables.SelectMany(list => list).Distinct().Count();
        }

        public void importIRViaSignal(List<string> signal, int irindex, string tableCaption)
        {
            if (signal.FirstOrDefault(s => s.ToLower().Contains("signal name") || s.ToLower().Contains("textual representation")) == null)
                interfaceRequirement[irindex].signals.Add(signal);
            else
            {
                //Add columns as new signal representation - set up the names add indexes (for example: Signal Name, Textual Representation, and Description)
                for (int i = 0; i < signal.Count(); i++)
                    if (interfaceRequirement[irindex].sr.Where(x => x.name == signal[i]).Count() == 0
                        && interfaceRequirement[irindex].sr.Where(x => x.index == i).Count() == 0)
                    {
                        interfaceRequirement[irindex].sr.Add(new SignalRepresenations(i, signal[i]));
                        if (interfaceRequirement[irindex].sr.Last().isSignalName()) interfaceRequirement[irindex].SignalNameIndex = i;
                        if (interfaceRequirement[irindex].sr.Last().isTextualRepresentation()) interfaceRequirement[irindex].TextualRepresentationIndex = i;
                        if (interfaceRequirement[irindex].sr.Last().isDescription()) interfaceRequirement[irindex].DescriptionIndex = i;
                    }
            }
        }

        public void UpdateInterfaceVariables()
        {
            foreach (var sigRep in interfaceRequirement[(int)SystemModel.InterfaceTypes.Inputs].sr)
            {
                if (sigRep.isSignalName())
                {
                    foreach (var sigName in interfaceRequirement[(int)SystemModel.InterfaceTypes.Inputs].signals)
                    {
                        inputVariables.Add(sigName[sigRep.index].ToLower());
                    }
                }
            }
            foreach (var sigRep in interfaceRequirement[(int)SystemModel.InterfaceTypes.Outputs].sr)
            {
                if (sigRep.isSignalName())
                {
                    foreach (var sigName in interfaceRequirement[(int)SystemModel.InterfaceTypes.Outputs].signals)
                    {
                        outputVariables.Add(sigName[sigRep.index].ToLower());
                    }
                }
            }
            foreach (var sigRep in interfaceRequirement[(int)SystemModel.InterfaceTypes.Internals].sr)
            {
                if (sigRep.isSignalName())
                {
                    foreach (var sigName in interfaceRequirement[(int)SystemModel.InterfaceTypes.Internals].signals)
                    {
                        outputVariables.Add(sigName[sigRep.index].ToLower());
                    }
                }
            }
        }

        /// <summary>
        /// Replaces all occurrences of both Textual Representation and Description with corresponding Signal Name
        /// Makes all remaining variables safe (no white spaces or forbidden characters).
        /// Also makes sure that redundant parentheses around a variable are removed.
        /// </summary>
        /// <param name="text">requirement text to be replaced</param>
        /// <param name="requirementIndex">requirementIndex of a specific requirements for which the variable list will be used.
        ///                                -1 for all requirement indeces.
        /// </param>
        /// <returns></returns>
        public string replaceWithSignalNames(string text, int requirementIndex)
        {
            if (text.Trim() == "")
                return "";
            text = propositionFromTable(text);

            mergeAllSignals();
            
            // Make sure that the resulting variable name is without white-spaces for LTL and SMT, 
            // even when the variable is not within interface requirements.
            IOrderedEnumerable<StructVariable> orderedVariables;
            if (requirementIndex == -1)
                orderedVariables = reqs.RequirementVariableList.SelectMany(l => l).ToList().Distinct().OrderBy(x => -x.name.Length);
            else
                orderedVariables = reqs.RequirementVariableList[requirementIndex].OrderBy(x => -x.name.Length);
            foreach (var structvar in orderedVariables)
            {
                text = text.Replace(structvar.name, safeName(structvar.name));
                if (structvar.datatype == StructVariable.DataType.SameAs)
                    text = text.Replace(structvar.instance, safeName(structvar.instance));
            }

            // The assumption is that description representation is longer that textual representation

            int InterfaceType = (int)SystemModel.InterfaceTypes.Inputs;
            // If only description column and signal name column are defined
            if (interfaceRequirement[InterfaceType].sr.Where(x => x.isDescription()).Count() == 1)
                // For all signals in, where there are enough representations, and ordered by length of description representation in descending order..
                foreach (var sig in allsignals.Where(z => z.Count >
                    Math.Max(interfaceRequirement[InterfaceType].DescriptionIndex, interfaceRequirement[InterfaceType].SignalNameIndex)).
                    OrderByDescending(x => x[interfaceRequirement[InterfaceType].DescriptionIndex].Length))
                {
                    text = text.Replace(safeName(sig[interfaceRequirement[InterfaceType].DescriptionIndex]),
                        sig[interfaceRequirement[InterfaceType].SignalNameIndex]); /// replace all occurrences of Description with corresponding Signal Name   
                }
            // If only textual representation column and signal name column are defined
            if (interfaceRequirement[InterfaceType].sr.Where(x => x.isTextualRepresentation()).Count() == 1)
                // For all signals, where there are enough representations, which are ordered by length of textual representation in descending order..
                foreach (var sig in allsignals.Where(z => z.Count >
                    Math.Max(interfaceRequirement[InterfaceType].TextualRepresentationIndex, interfaceRequirement[InterfaceType].SignalNameIndex)).
                    OrderByDescending(x => x[interfaceRequirement[InterfaceType].TextualRepresentationIndex].Length))
                {
                    text = text.Replace(safeName(sig[interfaceRequirement[InterfaceType].TextualRepresentationIndex]),
                        sig[interfaceRequirement[InterfaceType].SignalNameIndex]); /// replace all occurrences of Textual Representation with corresponding Signal Name
                }

            return text;
        }

        /// Replaces all occurrences of Signal Name with corresponding either Textual Representation or Description
        public string replaceWithTextualRepresentation(string text)
        {
            if (text.Trim() == "")
                return "";
            text = propositionFromTable(text);

            mergeAllSignals();

            // The assumption is that signal names are unique
            int InterfaceType = (int)SystemModel.InterfaceTypes.Inputs;

            // If only textual representation column and signal name column are defined
            if (interfaceRequirement[InterfaceType].sr.Where(x => x.isTextualRepresentation()).Count() == 1)
                // For all signals, where there are enough representations, which are ordered by length of textual representation in descending order..
                foreach (var sig in allsignals.Where(z => z.Count >
                    Math.Max(interfaceRequirement[InterfaceType].TextualRepresentationIndex, interfaceRequirement[InterfaceType].SignalNameIndex)).
                    OrderByDescending(x => x[interfaceRequirement[InterfaceType].SignalNameIndex].Length))
                {
                    text = text.Replace(sig[interfaceRequirement[InterfaceType].SignalNameIndex],
                        sig[interfaceRequirement[InterfaceType].TextualRepresentationIndex]); /// replace all occurrences of Signal Name with corresponding Textual Representation
                }

            // If only description column and signal name column are defined
            if (interfaceRequirement[InterfaceType].sr.Where(x => x.isDescription()).Count() == 1)
                // For all signals in, where there are enough representations, and ordered by length of description representation in descending order..
                foreach (var sig in allsignals.Where(z => z.Count >
                    Math.Max(interfaceRequirement[InterfaceType].DescriptionIndex, interfaceRequirement[InterfaceType].SignalNameIndex)).
                    OrderByDescending(x => x[interfaceRequirement[InterfaceType].SignalNameIndex].Length))
                {
                    text = text.Replace(sig[interfaceRequirement[InterfaceType].SignalNameIndex],
                        sig[interfaceRequirement[InterfaceType].DescriptionIndex]); /// replace all occurrences of Signal Name with corresponding Description
                }

            return text;
        }


        private void mergeAllSignals()
        {
            // marge all input, output and internal signals so that the replacement works,
            // even when different interface requirement names could collide, i.e. when one name is contained in another.
            allsignals = new List<List<string>>();
            // The assumption is that interface requirements indexes of 
            // signal name, description and textual representation are the same
            foreach (InterfaceRequirements ir in interfaceRequirement) // for input, output and internal requirement
            {
                // if signal representations contains signal name and either description or textual representations
                if (ir.sr != null && ir.sr.Where(x => x.isSignalName()).Count() == 1 &&
                    (ir.sr.Where(x => x.isDescription()).Count() == 1 ||
                      ir.sr.Where(x => x.isTextualRepresentation()).Count() == 1))
                    allsignals.AddRange(ir.signals);
            }
        }


        /// <summary>
        /// When input proposition is in the form "column Column Header[i] from table Number", instanciate it
        /// and return proposition that is a Signal Name corresponding actual value from given column and given table.
        /// </summary>
        /// <param name="proposition"></param>
        /// <returns></returns>
        public string propositionFromTable(string proposition)
        {
            Regex r = new Regex(@"column ([A-Za-z][A-Za-z0-9_ ]*) from table ([0-9-.]+)");
            List<string> allPropositions = new List<string>();
            while (r.IsMatch(proposition)) // column ...[i] from table ...
            {
                var matchtc = r.Match(proposition);
                Dictionary<string, List<string>> table;
                TableRequirements.TryGetValue(matchtc.Groups[2].Value, out table);
                if (table == null)
                {
                    proposition += "\nERROR: There is no table with ID: " + matchtc.Groups[2].Value;
                    break;
                }
                List<string> column;
                table.TryGetValue(matchtc.Groups[1].Value.Replace(" ", ""), out column);
                if (column == null)
                {
                    proposition += "\nERROR: There is no column with caption: " + matchtc.Groups[1].Value + " in Table " + matchtc.Groups[2].Value;
                    break;
                }
                if (allPropositions.Count() == 0)
                    foreach (var row in column)
                    {
                        allPropositions.Add(proposition.Replace(matchtc.Value, safeName(row)));
                    }
                else
                {
                    if (allPropositions.Count() != column.Count())
                    {
                        proposition += "\nERROR: Not matching assosiated columns " + matchtc.Groups[1].Value + "count" + allPropositions.Count() + " in Table " + matchtc.Groups[2].Value;
                        break;
                    }
                    foreach (var row in column)
                    {
                        allPropositions[column.IndexOf(row)] = allPropositions[column.IndexOf(row)].Replace(matchtc.Value, safeName(row));
                    }
                }
                proposition = proposition.Replace(matchtc.Value, safeName(column.First()));
            }
            if (allPropositions.Count > 0)
                return string.Join("\n\n", allPropositions);
            else
                return proposition;
        }


        /// <summary>
        ///  Make the input (name of the block or variable) C++ and SMV, Simulink safe 
        ///  So that the name do not collide with C++, SMV or our Simulink library keywords
        ///  Make sure this function is the same as the function "safeName" in perl transformation source code
        ///  Also make it lowercase that the name could be safely used as proposition within LTL for DIVINE.
        /// </summary>
        public static string safeName(string name)
        {
            if (name == "Abs" ||
                name == "alignas" ||
                name == "alignof" ||
                name == "and" ||
                name == "asm" ||
                name == "atan2" ||
                name == "Atan2" ||
                name == "auto" ||
                name == "BitwiseAnd" ||
                name == "Block" ||
                name == "bool" ||
                name == "break" ||
                name == "case" ||
                name == "catch" ||
                name == "char" ||
                name == "char16_t" ||
                name == "char32_t" ||
                name == "class" ||
                name == "connect" ||
                name == "const" ||
                name == "const_cast" ||
                name == "constexpr" ||
                name == "constant" ||
                name == "Constant" ||
                name == "continue" ||
                name == "Clock" ||
                name == "DataTypeConversion" ||
                name == "Deadzone" ||
                name == "decltype" ||
                name == "default" ||
                name == "delete" ||
                name == "DemuxScalar" ||
                name == "Demux" ||
                name == "do" ||
                name == "double" ||
                name == "dynamic_cast" ||
                name == "else" ||
                name == "enum" ||
                name == "Element" ||
                name == "EnablePort" ||
                name == "explicit" ||
                name == "Exponential" ||
                name == "export" ||
                name == "extern" ||
                name == "false" ||
                name == "float" ||
                name == "for" ||
                name == "friend" ||
                name == "From" ||
                name == "Gain" ||
                name == "goto" ||
                name == "Goto" ||
                name == "Ground" ||
                name == "GuardTransition" ||
                name == "if" ||
                name == "ImmediateTransition" ||
                name == "In" ||
                name == "in" ||
                name == "init" || // NuSMV keyword
                name == "inline" ||
                name == "InOutPort" ||
                name == "Inport" ||
                name == "InSet" ||
                name == "int" ||
                name == "Logic" ||
                name == "LogicAnd" ||
                name == "LogicNand" ||
                name == "LogicNor" ||
                name == "LogicNot" ||
                name == "LogicOr" ||
                name == "LogicXor" ||
                name == "Lookup" ||
                name == "LookupND" ||
                name == "long" ||
                name == "Math" ||
                name == "MathExp" ||
                name == "MathMod" ||
                name == "MathPow" ||
                name == "MathSqrt" ||
                name == "MinMax" ||
                name == "Modulus" ||
                name == "MultiPortSwitch" ||
                name == "mutable" ||
                name == "namespace" ||
                name == "new" ||
                name == "noexcept" ||
                name == "not" ||
                name == "nullptr" ||
                name == "operator" ||
                name == "or" ||
                name == "out" ||
                name == "Outport" ||
                name == "private" ||
                name == "Product" ||
                name == "protected" ||
                name == "public" ||
                name == "register" ||
                name == "reinterpret_cast" ||
                name == "RelationalOperator" ||
                name == "return" ||
                name == "Rounding" ||
                name == "Saturate" ||
                name == "Serialise" ||
                name == "short" ||
                name == "SignalConversion" ||
                name == "signed" ||
                name == "Signum" ||
                name == "sizeof" ||
                name == "Square" ||
                name == "State" ||
                name == "StateflowObj" ||
                name == "Stateful" ||
                name == "StateOr" ||
                name == "static" ||
                name == "static_assert" ||
                name == "static_cast" ||
                name == "struct" ||
                name == "Sum" ||
                name == "Switch" ||
                name == "switch" ||
                name == "System" ||
                name == "template" ||
                name == "Terminator" ||
                name == "TestBlock" ||
                name == "this" ||
                name == "thread_local" ||
                name == "throw" ||
                name == "Trigonometry" ||
                name == "Transition" ||
                name == "true" ||
                name == "try" ||
                name == "typedef" ||
                name == "typeid" ||
                name == "typename" ||
                name == "union" ||
                name == "unsigned" ||
                name == "UnitDelay" ||
                name == "using" ||
                name == "Value" ||
                name == "virtual" ||
                name == "void" ||
                name == "volatile" ||
                name == "wchar_t" ||
                name == "while" ||
                name == "Mux" ||
                name == "zero") // part of Control Systems structured grammar
            {
                name = name + "_zis9apx7";
            }
            name = name.Replace("<", "lt");
            name = name.Replace(">", "gt");
            name = name.Replace("~=", "neq");
            name = name.Replace("!", "not");
            name = name.Replace("=", "eq");
            name = name.Replace("+", "plus");
            name = name.Replace("-", "minus");
            name = name.Replace("*", "times");
            name = name.Replace("/", "div");
            name = name.Replace("&", "bitAND");
            name = name.Replace("|", "bitOR");
            name = name.Replace(":", "_");
            name = name.Replace(" ", "_");
            name = name.Replace('\'', '_');
            name = name.Replace('"', '_');
            name = name.Replace('“', '_');
            name = name.Replace('”', '_');
            name = name.Replace("(", "_");
            name = name.Replace(")", "_");
            name = name.Replace(",", "comma");
            name = name.Replace(".", "dot");

            return name.Trim(new char[] { '_' }); // Remove unnecessary characters "_"
        }


        /// <summary>
        /// Function that reverses safeName function from length of the string point of view.
        /// Works only for names with " " or "-"..
        /// Therefore, for each name, antiSafeName(safeName(name)).length() == name.length()
        /// </summary>
        /// <param name="safeName"></param>
        /// <returns></returns>
        public string antiSafeName(string safeName)
        {
            safeName = safeName.Replace("_zis9apx7", "");
            safeName = safeName.Replace("minus", "-");
            safeName = safeName.Replace("_", " ");
           return safeName;
        }       

        public void FillUncoveredImpliedVariables(bool close)
        {
            RemoveUncoveredImpliedVariables();
            if (close)
            {
                if (reqs.RequirementVariableList.Count <= reqs.requirementIndex ||
                    reqs.RequirementVariableList[reqs.requirementIndex].Count == 0)
                {
                    return;
                }
                uncoveredImpliedVariables = new List<string>();
                foreach (string var in reqs.RequirementVariableList[reqs.requirementIndex].Select(x => x.name))
                {
                    bool found = false;
                    // For all types of variables (inputs, output and internal)
                    for (int index = 0; index < 3; index++)
                    {
                        for (int i = 0; i < interfaceRequirement[index].signals.Count(); i++)
                        {
                            if (interfaceRequirement[index].TextualRepresentationIndex < interfaceRequirement[index].signals[i].Count
                                && interfaceRequirement[index].TextualRepresentationIndex >= 0)
                            {
                                if (interfaceRequirement[index].signals[i][interfaceRequirement[index].TextualRepresentationIndex] == var)
                                {
                                    found = true;
                                    break;
                                }
                            }
                        }
                    }
                    if (!found)
                    {
                        if (uncoveredImpliedVariables.Find(s => s.Equals(var)) == null)
                            uncoveredImpliedVariables.Add(var);
                    }
                }
                // For all types of variables (inputs, output and internal)
                for (int index = 0; index < 3; index++)
                {
                    foreach (string var in uncoveredImpliedVariables)
                    {
                        var signal = new List<string>();
                        signal.Add("not available");
                        signal.Add(var);
                        signal.Add("implied signal not covered by interface requirements");
                        interfaceRequirement[index].signals.Add(signal);
                    }
                }
            }
        }//FillUncoveredImpliedVariables

        void RemoveUncoveredImpliedVariables()
        {
            // For all types of variables (inputs, output and internal)
            for (int index = 0; index < 3; index++)
                if (uncoveredImpliedVariables != null)
                    foreach (string var in uncoveredImpliedVariables)
                    {
                        for (int i = interfaceRequirement[index].signals.Count() - 1; i >= 0; i--)
                        {
                            if (interfaceRequirement[index].SignalNameIndex >= 0 &&
                                interfaceRequirement[index].signals[i][interfaceRequirement[index].TextualRepresentationIndex] == var)
                            {
                                interfaceRequirement[index].signals.RemoveAt(i);
                                break;
                            }
                        }
                    }
        }//RemoveUncoveredImpliedVariables

        public void FillUncoveredSignals()
        {
            uncoveredSignals = new List<string>[2]; // input, output (internals do not have to be covered at all)
            uncoveredVariables = new List<string>[2];
            for (int index = 0; index < 2; index++) // input and output signals only (internals and parameters do not have to be covered at all)
            {
                uncoveredSignals[index] = new List<string>();
                uncoveredVariables[index] = new List<string>();

                if (interfaceVariables[index].Count() == 0)
                    return;

                for (int i = 0; i < interfaceRequirement[index].signals.Count(); i++)
                {
                    if (interfaceRequirement[index].signals[i].Count > interfaceRequirement[index].SignalNameIndex)
                    {
                        if (interfaceRequirement[index].SignalNameIndex >= 0 &&
                            interfaceVariables[index].Find(s => s.Equals(interfaceRequirement[index].signals[i][interfaceRequirement[index].SignalNameIndex])) == null)
                        {
                            uncoveredSignals[index].Add(interfaceRequirement[index].signals[i][interfaceRequirement[index].SignalNameIndex]);
                        }
                    }
                }

                foreach (string var in interfaceVariables[index])
                {
                    bool found = false;
                    for (int i = 0; i < interfaceRequirement[index].signals.Count(); i++)
                    {
                        if (interfaceRequirement[index].SignalNameIndex < interfaceRequirement[index].signals[i].Count)
                        {
                            if (interfaceRequirement[index].SignalNameIndex >= 0 &&
                                interfaceRequirement[index].signals[i][interfaceRequirement[index].SignalNameIndex] == var)
                            {
                                found = true;
                                break;
                            }
                        }
                    }
                    if (!found)
                    {
                        if (uncoveredVariables[index].Find(s => s.Equals(var)) == null)
                            uncoveredVariables[index].Add(var);
                    }
                }
                foreach (string var in uncoveredVariables[index])
                {
                    var signal = new List<string>();
                    signal.Add(var);
                    signal.Add("not defined");
                    signal.Add("not defined");
                    interfaceRequirement[index].signals.Add(signal);
                }
            }
        }//FillUncoveredSignals       

        public void RemoveUncoveredSignals()
        {
            for (int index = 0; index < 2; index++) // input and output signals only (internals do not have to be covered at all)
                if (uncoveredVariables != null && uncoveredVariables[index] != null)
                    foreach (string var in uncoveredVariables[index])
                    {
                        for (int i = interfaceRequirement[index].signals.Count() - 1; i >= 0; i--)
                        {
                            if (interfaceRequirement[index].SignalNameIndex >= 0 &&
                                interfaceRequirement[index].signals[i][interfaceRequirement[index].SignalNameIndex] == var)
                            {
                                interfaceRequirement[index].signals.RemoveAt(i);
                                break;
                            }
                        }
                    }

            for (int i = 0; i < 2; i++) // input, output
            {
                if (uncoveredSignals != null)
                    uncoveredSignals[i] = new List<string>();
                if (uncoveredVariables != null)
                    uncoveredVariables[i] = new List<string>();
            }
        }//RemoveUncoveredSignals

        public VerificationType getVerificationType()
        {
            if (exists())
                return VerificationType.CorrectnessChecking;
            else
                return VerificationType.RequirementAnalysis;
        }
        
        public bool isC()
        {
            Console.WriteLine("systemname {0}", systemName);
            return ToolKit.isCFilename(systemName);
        }
        

        public string timeSpentOnRequirements()
        {
            string times = "";
            for (int requirementIndex = 0; requirementIndex < reqs.requirements.Count; requirementIndex++)
                times += reqs.getReqIFAttribute("TIME-SPENT", ((XmlElement)reqs.requirements[requirementIndex]))+';';
            return times;
        }


        /// <summary>
        /// Convert a matched LTL property index to a corresponding requirement ID
        /// </summary>
        /// <param name="match">matched requirement index</param>
        /// <returns>corresponding requirement ID</returns>
        public string FromIndexToID(Match match)
        {
            int propertyIndex = 0;
            int matchedPropertyIndex = Convert.ToInt32(match.Value);
            string formula;
            int LTLs;
            for (int requirementIndex = 0; requirementIndex < reqs.requirements.Count; requirementIndex++)
            {
                var req = ((XmlElement)reqs.requirements[requirementIndex]);
                if (reqs.getReqIFAttribute("Formalization Progress", req) == "Formal")
                {
                    formula = reqs.getReqIFAttribute("LTL Formula Full", req);
                    LTLs = formula.Split(new string[] { "\n\n" }, StringSplitOptions.RemoveEmptyEntries).Count();
                    // For each LTL structure index (could be multiple in single requirement separated by "\n\n")
                    for (int LTLIndex = 0; LTLIndex < LTLs; LTLIndex++)
                    {
                        if (propertyIndex == matchedPropertyIndex)
                            return ((LTLs>1)?"part of ":"")+req.GetAttribute("IDENTIFIER");
                        propertyIndex++;
                    }
                }
            }
            // in the worst case return formal requirement index from 1
            return matchedPropertyIndex.ToString() + ". formal requirement";
        }

        public bool variableExists(int index, string varName)
        {
            return interfaceVariables[index].Contains(varName);
        }

        public string variableType(int index, string varName)
        {
            int id = interfaceVariables[index].IndexOf(varName);
            if (id < 0 || id >= interfaceVariablesTypes[index].Count())
                return "unknown";
            else
                return interfaceVariablesTypes[index].ElementAt(id);
        }

        public string convertType(string varName)
        {
            if (variableExists(0, varName))
            {
                return variableType(0, varName);
            }
            if (variableExists(1, varName))
            {
                return variableType(0, varName);
            }
            return "";
        }

        /// <summary>
        /// Analyzes the generated C file for maximum length of variable names and stores that as maximumIdentifierLength.
        /// Looks for variable names in the form shortened_model_name_X where X is B,U,P or Y
        /// </summary>
        /// <created>MiD,2019-06-20</created>
        /// <changed>MiD,2019-06-20</changed>
        public void updateMaximumIdentifierLength()
        {
            if (cName == null || !File.Exists(cName))
                throw new FileNotFoundException("cannot open systemModel.cName");
            // Read the generated C file:
            string cContent = File.ReadAllText(cName);
            // Look for all words in the form *_X:
            MatchCollection matches = Regex.Matches(cContent, @"(\w*)_(?:B|U|P|Y)");
            // Filter those matches where the parts before _X are prefixes and get maximum length of those:
            maximumIdentifierLength = matches.Cast<Match>().Where(m => modelName.StartsWith(m.Groups[1].Value)).Max(m => m.Groups[0].Length);
        }

        /// <summary>
        /// Creates a variable name with full postfix and potentially trimmed prefix, so that the entire name does not exceed maximumIdentifierLength
        /// Throws OutOfRangeException if postfix is too long.
        /// </summary>
        /// <param name="prefix"></param>
        /// <param name="postfix"></param>
        /// <returns></returns>
        /// <created>MiD,2019-06-20</created>
        /// <changed>MiD,2019-06-20</changed>
        public string formCVariableName(string prefix, string postfix)
        {
            if (postfix.Length >= maximumIdentifierLength)
                throw new IndexOutOfRangeException("postfix is longer than maximum identifier length!");
            return prefix.Substring(0, Math.Min(prefix.Length, maximumIdentifierLength - postfix.Length)) + postfix;
        }

        /// <summary>
        /// Returns readable list of system names from systempaths.
        /// For example, when systempaths = {"...\example\root.c", "...\example\avionics.c"}
        /// reutrn: "2 (.c) files: root.c, avionics.c"
        /// </summary>
        /// <returns></returns>
        public string getSystemNames()
        {
            string names = systemPaths.Count().ToString();
            if (systemPaths.All(p => Path.GetExtension(p) == Path.GetExtension(systemPath)))
                names += " (" + Path.GetExtension(systemPath) + ")";
            return names + " files: " + String.Join(", ", systemPaths.ConvertAll(p => Path.GetFileNameWithoutExtension(p)));
        }
    }
}
